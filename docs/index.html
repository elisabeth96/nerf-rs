<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>NeRF in rust</title>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            margin: 2rem;
            line-height: 1.6;
            color: #222;
            background-color: #fafafa;
        }
        header {
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 1.5rem;
        }
        h1, h2 {
            color: #0a4b78;
        }
        a {
            color: #0c70b6;
        }
        section {
            margin-bottom: 2rem;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
        }
        button {
            background-color: #0c70b6;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.65rem 1.2rem;
        }
        button:disabled {
            background-color: #6ba8d6;
            cursor: not-allowed;
        }
        #renderStatus {
            margin-top: 1rem;
            font-weight: 600;
        }
        code {
            background-color: #efefef;
            padding: 0.15rem 0.3rem;
            border-radius: 4px;
        }
        ul {
            padding-left: 1.5rem;
        }
        canvas {
            border: 1px solid #d0d0d0;
            margin-top: 1rem;
        }
        .spinner {
            display: inline-block;
            width: 1.25rem;
            height: 1.25rem;
            border: 3px solid #c8daea;
            border-top-color: #0c70b6;
            border-radius: 50%;
            animation: spin 0.9s linear infinite;
            margin-left: 0.75rem;
            vertical-align: middle;
        }
        .spinner.hidden {
            display: none;
        }
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Neural Radiance Fields (NeRF) in Rust</h1>
        <p>This short page documents the background behind NeRF and the work implemented in the <code>nerf-rs</code> project.</p>
    </header>

    <section id="what-is-nerf">
        <h2>What is NeRF?</h2>
        <p>
            Neural Radiance Fields (NeRF) were introduced by Ben Mildenhall <em>et&nbsp;al.</em> in
            “<a href="https://arxiv.org/abs/2003.08934" target="_blank" rel="noopener noreferrer">NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</a>” (ECCV&nbsp;2020).
            The method optimizes a fully-connected neural network that maps a 3D position and viewing direction to color and volume density, allowing novel views of a scene to be rendered via volume rendering.
        </p>
        <ul>
            <li>A scene is represented implicitly: no mesh or explicit voxels are stored.</li>
            <li>Rendering uses stratified sampling along camera rays plus hierarchical importance resampling.</li>
            <li>Training requires multiple calibrated images of the scene along with known camera poses.</li>
        </ul>
        <p>
            Additional resources: the original project page (<a href="https://www.matthewtancik.com/nerf" target="_blank" rel="noopener noreferrer">matthewtancik.com/nerf</a>) and the open-source TensorFlow implementation (<a href="https://github.com/bmild/nerf" target="_blank" rel="noopener noreferrer">github.com/bmild/nerf</a>).
        </p>
    </section>

    <section id="implementation">
        <h2>Implementation Overview</h2>
        <p>
            The Rust implementation follows the structure of the original NeRF renderer while leveraging the pre-trained Lego scene weights under <code>lego_rust/</code>.
            Rendering happens in two passes per ray:
        </p>
        <ul>
            <li><strong>Coarse pass:</strong> 64 stratified samples between the near and far bounds are evaluated with the coarse MLP to estimate density along the ray.</li>
            <li><strong>Fine pass:</strong> 128 additional points are drawn by building a probability distribution from the coarse densities and resampling via inverse-CDF. These merged samples are then evaluated with the fine network to produce the final color.</li>
        </ul>
        <p>
            Key files and responsibilities include:</p>
        <ul>
            <li><code>src/network.rs</code>: matrix utilities, positional encodings, and batched forward passes for the coarse and fine MLPs.</li>
            <li><code>src/lib.rs</code>: camera setup, hierarchical sampling logic, volumetric integration, and the shared render pipeline used by both CLI and WebAssembly builds.</li>
            <li><code>lego_rust/</code>: serialized network weights and the reference sample JSON used for camera parameters and unit tests.</li>
        </ul>
        <p>
            Recent improvements introduced hierarchical resampling inside <code>render_image</code>, moving from a coarse-only renderer to the two-stage pipeline described in the paper. The unit test <code>tests::coarse_and_fine_match_reference_examples</code> continues to validate both networks against known samples.
        </p>
        <p>
            The native binary still uses Rayon for multithreaded rendering, while the WebAssembly build runs sequentially so it can be hosted anywhere (including GitHub Pages) without special headers.
        </p>
        <p>
            To replicate the rendering showcased in the paper, run <code>cargo run --release</code>; the output image (now rendered at <code>256 × 256</code>) will be written as <code>output.ppm</code> in the project root.
        </p>
    </section>

    <section id="render-action">
        <h2>Interactive Render (256×256)</h2>
        <p>
            Build the WebAssembly bundle once with
            <code>wasm-pack build --target web --release --out-dir docs/pkg</code> and publish the <code>docs/</code>
            folder (for example via GitHub Pages). After that, users just open the site and press the button—no extra setup required.
        </p>
        <button id="renderButton" type="button">Render 256×256 Image</button>
        <span id="renderSpinner" class="spinner hidden" aria-hidden="true"></span>
        <p id="renderStatus" role="status" aria-live="polite"></p>
        <canvas id="renderCanvas" width="256" height="256"></canvas>
    </section>

    <script type="module">
        import initWasm, { init_renderer, render_image_rgba } from './pkg/nerf_rs.js';

        const button = document.getElementById('renderButton');
        const statusNode = document.getElementById('renderStatus');
        const spinner = document.getElementById('renderSpinner');
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas?.getContext('2d');

        let wasmReady;

        async function ensureWasmReady() {
            if (!wasmReady) {
                wasmReady = (async () => {
                    await initWasm();
                    try {
                        await init_renderer();
                        statusNode.textContent = 'Renderer ready. Click the button to start.';
                    } catch (error) {
                        console.warn('Renderer initialisation skipped', error);
                    }
                })();
            }
            return wasmReady;
        }

        if (button && statusNode && ctx) {
            button.addEventListener('click', async () => {
                await ensureWasmReady();
                button.disabled = true;
                statusNode.textContent = 'Rendering 256×256 image… (this may take a few seconds)';
                spinner?.classList.remove('hidden');

                try {
                    const rgba = await render_image_rgba(256, 256);
                    const imageData = new ImageData(new Uint8ClampedArray(rgba), 256, 256);
                    ctx.putImageData(imageData, 0, 0);
                    statusNode.textContent = 'Render complete!';
                } catch (error) {
                    console.error(error);
                    statusNode.textContent = `Render failed: ${error}`;
                } finally {
                    button.disabled = false;
                    spinner?.classList.add('hidden');
                }
            });

            // Pre-load Wasm when the page is ready.
            ensureWasmReady();
        }
    </script>
</body>
</html>
